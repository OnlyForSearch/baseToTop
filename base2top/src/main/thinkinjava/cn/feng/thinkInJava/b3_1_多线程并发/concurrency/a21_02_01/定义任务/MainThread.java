package cn.feng.thinkInJava.b3_1_多线程并发.concurrency.a21_02_01.定义任务;
//: concurrency/MainThread.java


/**
 * 并发的多样性

 并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。
 更快的执行

 并发通常是提高运行在单处理器上的程序的性能。如果程序中的一个任务阻塞了，其他任务可以继续执行，如果没有阻塞，那么单处理器上使用并发就没有任何意义，反而还增加了上下文切换的代价。使用并发就好像cpu可以同时位于两处一样，这仅仅是错觉，但是多处理器的话，就不只是错觉了。

 提高单处理器系统性能的常见示例是事件驱动的编程。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。

 实现并发最直接的方式是在操作系统级别使用进程，进程是运行在自己的地址空间内的自包容程序。

 操作系统通常会将进程相互隔离，因此它们不会彼此干涉，这使得用进程编程相对容易一些。与此相反的是，向java所使用的这种并发系统会共享注入内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。

 某些编程语言被设计为可以将并发任务彼此隔离，通常被称为函数型语言，其中每个函数调用都不会产生任何副作用（并因此而不能干涉其他函数），并因此可以当作独立的任务来驱动。
 改进代码设计

 Java
 的线程机制是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每一个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动任务。在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识的在每个任务中插入某种类型的让步语句。协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。（注意：某些协作式系统并未设计为可以在多个处理器之前分布任务，这可能会非常受限）。
 * */
public class MainThread {

    public static void main(String[] args) {
      /*当从Runnable导出一个类时,它必须具有run()方法,但是这个方法并无特殊之处
       * 不会产生任何内在的线程能力.要实现线程的行为,必须显示的将一个任务附着到线程上
	   * */
        LiftOff launch = new LiftOff();
        launch.run();
    }
} /* Output:
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(Liftoff!),
*///:~
