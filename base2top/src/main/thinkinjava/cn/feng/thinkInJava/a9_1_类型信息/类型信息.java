package cn.feng.thinkInJava.a9_1_类型信息;

import org.junit.Test;

/**
 * Java在运行时识别对象信息的方式有两种 :1传统的RTTI(在运行时识别一个对象类型),2反射机制 应该在下列情况下使用异常 
 * a. 在恰当的级别处理问题(在知道该如何处理的情况下才捕获异常) b. 解决问题并且重新调用产生异常的方法 
 * c. 进行少许修补,然后绕过异常发生的地方继续执行 d. 用别的数据进行计算,以代替方法预计会返回的值 
 * e. 把当前运行环境下能做的事情尽量做完,然后把相同的异常重抛到更高层
 *  f.    把当前运行环境下能做的事情尽量做完,然后把不同的异常抛到更高层 g. 终止程序 
 * h. 进行简化(如果你的异常模式使问题变得太复杂,那用起来会非常痛苦也很烦人) 
 * i.    让类库和程序更安全(这既是在为调试做短期投资,也是在为程序的健壮性做长期投资)
 */
public class 类型信息 {

    @Test
    public void classDemo() {
        /*
         * 在多态的运用中，基类定义方法，子类重写或者重载该方法。在实际编程中，往往用基类的引用去代表继承自该类的所有子类，
		 * 那么该引用调用的方法必须是基类中已经定义的
		 * 。这样的话，在程序运行的时候，编译器自动发现是基类还是它的继承类，从而调用相应的方法。（我猜想，编译器就是通过RTTI发现类型信息的）。
		 * 
		 * 这样，使用多态机制的方法调用时，必须我们先知道了基类定义了什么方法，这就要求我们对基类定义的控制权。如果基类是来自一个库或者由别人控制，
		 * 这时候RTTI就是一种解决之道：可以继承一个新类，然后添加你要的方法。在代码的其他地方，可以检查你自己特定的类型，并调用你自己的方法。
		 * 
		 * 所以说RTTI可以说和多态没有关系，但是我想在多态的实现机制上，肯定用到了RTTI。
		 * 
		 * 
		 * 
		 * PS:
		 * 
		 * 在Java中，RTTI表现在：
		 * 1。Class对象，是RTTI的核心，每个类都有一个class对象。每当编写并且编译一个新类，就会产生一个Class对象
		 * （被保存在同名的.class文件当中）
		 * 
		 * 2。instanceof 关键字用于检查对象是不是某个特定类型的实例。
		 * 
		 * 3。强制类型转换，如： Parent object = new Child(); Child child = (Child)object;
		 * 
		 * 至于实现机制，根据JVM实现的不同，没有固定的答案。
		 * 
		 * 
		 * 
		 * PS：
		 * 
		 * RTTI主要主要针对对象：Class对象。Class对象存放着对应类所需要的所有的类型信息，包括类的变量，类的属性，类的超类，类实现的接口，
		 * 类的修饰符，类的对应的类的加载器等等
		 * 所有类都在第一次使用时，动态加载入jvm当中，当程序创建对类的第一个静态引用时，就会加载这个类，同时构造器可以看作是一个静态方法。
		 * jvm是动态加载的
		 * ，你需要什么我给你加载什么，这样的话，类加载器第一次使用该类时，他会检查这个类的class对象，有没有被加载，如果没有加载
		 * ，就载入这个class对象
		 * ，加载时需要对class文件验证，包括文件头，文件大小，文件内容语义检查，各类字符串引用检查等等，载入后，还有链接和初始化等两个步骤。
		 * 常常初始化行为被延迟到了对静态方法或者非常量静态域进行首次引用时才被执行。对于常量静态域是因为他在编译器的时候，已经被搞定了。
		 * 此外RTTI的表现形式有： 1.进行类型转换，这个主要是进行向下类型转换时使用，可以概括为：你是什么类型就可以从基类型转化什么类型
		 * 
		 * 2 通过查询class对象可以获取运行时的所需的信息
		 */
    }
}
